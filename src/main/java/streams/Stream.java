package streams;

import java.util.*;

public class Stream {
    private static final String completeId = "^\\d+-\\d+$";                    // 123-456
    private static final String autoGeneratedSequenceId = "^\\d+-\\*$";        // 123-*
    private static final String fullyAutoGeneratedId = "^\\*$";                // *

    private final Map<String, StreamEntry> entries;

    public Stream() {
        entries = new LinkedHashMap<>();
    }

    public String addEntry(StreamEntry entry) {
        String id = entry.id();
        if (id.matches(autoGeneratedSequenceId)) {
            id = generateIdSequence(id); // return the id(timestamp) with generated sequence number

        } else if (id.matches(fullyAutoGeneratedId)) {
            id = generateFullId();

        } else if (!id.matches(completeId)) {
            throw new IllegalArgumentException("ERR Invalid stream ID specified: " + id);
        }

        validateEntryId(id);
        entry = new StreamEntry(id, entry.fields());
        entries.put(id, entry);
        return entry.id();
    }

    public Map<String, StreamEntry> getEntries() {
        return entries;
    }

    public String getLastEntryId() {
        if (entries.isEmpty()) {
            return "0-0";
        }

        return entries.keySet().stream().skip(entries.size() - 1).findFirst().orElse("0-0");
    }

    // logic needs to be improved (should be considering last entry instead of looping)
    private String generateIdSequence(String id) {
        String[] idParts = id.split("-");
        String idTimeStamp = idParts[0];
        String timeStampLastKey;
        long sequence;

        if (Long.parseLong(idTimeStamp) == 0) { // reject 0-0, start from 0-1
            timeStampLastKey = idTimeStamp + "-1"; // 0-1
            sequence = 1; // start counting from 1
        } else {
            timeStampLastKey = idTimeStamp + "-0"; // <number>-0
            sequence = 0; // start counting from 0
        }

        while (entries.containsKey(timeStampLastKey)) {
            sequence++;
            timeStampLastKey = idTimeStamp + '-' + sequence;
        }

        return timeStampLastKey;
    }

    // this works since entries are sorted by timestamp and sequence number (monotonically increasing)
    private String generateFullId() {
        long timestamp = System.currentTimeMillis();
        long sequence = 0;
        long[] lastEntryId = parseEntryId(getLastEntryId());

        // checks if current timestamp is lesser than the last entry timestamp (previously defined by client)
        if (timestamp <= lastEntryId[0]) {
            timestamp = lastEntryId[0];
            sequence = lastEntryId[1] + 1;
            return timestamp + "-" + sequence;
        }

        return timestamp + "-" + sequence;
    }

    private long[] parseEntryId(String entryId) {
        String[] parts = entryId.split("-");
        try {
            return new long[]{Long.parseLong(parts[0]), Long.parseLong(parts[1])};
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("ERR Invalid stream ID specified: " + entryId);
        }
    }

    private int compareIDs(String id1, String id2) {
        long[] id1Parts = parseEntryId(id1);
        long[] id2Parts = parseEntryId(id2);

        // compare time first if different
        if (id1Parts[0] != id2Parts[0]) {
            return Long.compare(id1Parts[0], id2Parts[0]);
        }

        // if they are equal, compare sequence numbers
        return Long.compare(id1Parts[1], id2Parts[1]);
    }

    public void validateEntryId(String id) {
        // id must be bigger than 0-0
        if (compareIDs(id, "0-1") < 0) {
            throw new IllegalArgumentException("ERR The ID specified in XADD must be greater than 0-0");
        }

        String lastId = getLastEntryId();
        if (compareIDs(id, lastId) <= 0) {
            throw new IllegalArgumentException("ERR The ID specified in XADD is equal or smaller than the target stream top item");
        }
    }

    public List<StreamEntry> getEntriesInRange(String startId, String endId, boolean IsExclusiveStart) {
        if (startId.equals("-")) {
            startId = entries.keySet().stream().findFirst().orElse("0-0");
        }
        
        if (endId.equals("+")) {
            endId = getLastEntryId();
        }
        
        // Handle special case for start ID without sequence
        if (startId.matches("^\\d+$")) {
            startId = startId + "-0";  // Default to sequence 0 for start
        }

        // Handle special case for end ID without sequence
        if (endId.matches("^\\d+$")) {
            // For end ID, use maximum sequence possible
            endId = endId + "-" + Long.toString(Long.MAX_VALUE);  // Max 64-bit integer
        }

        // validate range
        if (compareIDs(startId, endId) > 0) {
            throw new IllegalArgumentException("ERR Invalid range specified: " + startId + "-" + endId);
        }

        // if start range is bigger that last entry then return empty list
        if (compareIDs(startId, getLastEntryId()) > 0) {
            return new ArrayList<>();
        }

        List<StreamEntry> entriesInRange = new ArrayList<>();
        Iterator<Map.Entry<String, StreamEntry>> itr = entries.entrySet().iterator();


        while (itr.hasNext()) {
            Map.Entry<String, StreamEntry> entry = itr.next();
            String id = entry.getKey();

            if (IsExclusiveStart && compareIDs(id, startId) <= 0) {
                continue;
            }

            if (compareIDs(id, startId) < 0) {
                continue;
            }

            if (compareIDs(id, endId) > 0) {
                break;
            }

            entriesInRange.add(entry.getValue());
        }

        return entriesInRange;
    }

    public List<StreamEntry> getInclusiveRange(String startId, String endId) {
        return getEntriesInRange(startId, endId, false);
    }

    // this method returns result exclusively
    public List<StreamEntry> getEntriesGreaterThan(String startId) {
        return getEntriesInRange(startId, "+", true);
    }
}
