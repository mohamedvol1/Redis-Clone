package streams;

import java.util.LinkedHashMap;
import java.util.Map;

public class Stream {
    private static final String completeId = "^\\d+-\\d+$";                    // 123-456
    private static final String autoGeneratedSequenceId = "^\\d+-\\*$";        // 123-*
    private static final String fullyAutoGeneratedId = "^\\*$";                // *

    private final Map<String, StreamEntry> entries;

    public Stream() {
        entries = new LinkedHashMap<>();
    }

    public String addEntry(StreamEntry entry) {
        String id = entry.id();
        if (id.matches(autoGeneratedSequenceId)) {
            id = generateIdSequence(id); // return the id(timestamp) with generated sequence number

        } else if (id.matches(fullyAutoGeneratedId)) {
            id = generateFullId();

        } else if (!id.matches(completeId)) {
            throw new IllegalArgumentException("ERR Invalid stream ID specified: " + id);
        }

        validateEntryId(id);
        entry = new StreamEntry(id, entry.fields());
        entries.put(id, entry);
        return entry.id();
    }

    public Map<String, StreamEntry> getEntries() {
        return entries;
    }

    public String getLastEntryId() {
        if (entries.isEmpty()) {
            return "0-0";
        }

        return entries.keySet().stream().skip(entries.size() - 1).findFirst().orElse("0-0");
    }

    // logic needs to be improved (should be considering last entry instead of looping)
    private String generateIdSequence(String id) {
        String[] idParts = id.split("-");
        String idTimeStamp = idParts[0];
        String timeStampLastKey;
        long sequence;

        if (Long.parseLong(idTimeStamp) == 0) { // reject 0-0, start from 0-1
            timeStampLastKey = idTimeStamp + "-1"; // 0-1
            sequence = 1; // start counting from 1
        } else {
            timeStampLastKey = idTimeStamp + "-0"; // <number>-0
            sequence = 0; // start counting from 0
        }

        while (entries.containsKey(timeStampLastKey)) {
            sequence++;
            timeStampLastKey = idTimeStamp + '-' + sequence;
        }

        return timeStampLastKey;
    }

    // this works since entries are sorted by timestamp and sequence number (monotonically increasing)
    private String generateFullId() {
        long timestamp = System.currentTimeMillis();
        long sequence = 0;
        long[] lastEntryId = parseEntryId(getLastEntryId());

        // checks if current timestamp is lesser than the last entry timestamp (previously defined by client)
        if (timestamp <= lastEntryId[0]) {
            timestamp = lastEntryId[0];
            sequence = lastEntryId[1] + 1;
            return timestamp + "-" + sequence;
        }

        return timestamp + "-" + sequence;
    }

    private long[] parseEntryId(String entryId) {
        String[] parts = entryId.split("-");
        try {
            return new long[]{Long.parseLong(parts[0]), Long.parseLong(parts[1])};
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("ERR Invalid stream ID specified: " + entryId);
        }
    }

    private int compareIDs(String id1, String id2) {
        long[] id1Parts = parseEntryId(id1);
        long[] id2Parts = parseEntryId(id2);

        // compare time first if different
        if (id1Parts[0] != id2Parts[0]) {
            return Long.compare(id1Parts[0], id2Parts[0]);
        }

        // if they are equal, compare sequence numbers
        return Long.compare(id1Parts[1], id2Parts[1]);
    }

    public void validateEntryId(String id) {
        // id must be bigger than 0-0
        if (compareIDs(id, "0-1") < 0) {
            throw new IllegalArgumentException("ERR The ID specified in XADD must be greater than 0-0");
        }

        String lastId = getLastEntryId();
        if (compareIDs(id, lastId) <= 0) {
            throw new IllegalArgumentException("ERR The ID specified in XADD is equal or smaller than the target stream top item");
        }
    }
}
