package streams;

import java.util.LinkedHashMap;
import java.util.Map;

public class Stream {
    private static final String completeId = "^\\d+-\\d+$";                    // 123-456
    private static final String autoGeneratedSequenceId = "^\\d+-\\*$";        // 123-*
    private static final String fullyAutoGeneratedId = "^\\*$";                // *

    private final Map<String, StreamEntry> entries;

    public Stream() {
        entries = new LinkedHashMap<>();
    }

    public String addEntry(StreamEntry entry) {
        String id = entry.id();
        if (id.matches(completeId)) {
            validateEntryId(id);
        } else if (id.matches(autoGeneratedSequenceId)) { // we wont validate in the next 2 cases since they are auto generated
            id = generateIdSequence(id); // return the id(timestamp) with generated sequence number
        } else if (id.matches(fullyAutoGeneratedId)) {
            // nothing for now
        }

        entry = new StreamEntry(id, entry.fields());
        entries.put(id, entry);
        return entry.id();
    }

    public Map<String, StreamEntry> getEntries() {
        return entries;
    }

    public String getLastEntryId() {
        if (entries.isEmpty()) {
            return "0-0";
        }

        return entries.keySet().stream().skip(entries.size() - 1).findFirst().orElse("0-0");
    }

    private String generateIdSequence(String id) {
        String[] idParts = id.split("-");
        String idTimeStamp = idParts[0];
        String timeStampLastKey;
        long sequence;
        if (Long.parseLong(idTimeStamp) == 0) { // reject 0-0, start from 0-1
            timeStampLastKey = idTimeStamp + "-1"; // 0-1
            sequence = 1; // start counting from 1
        } else {
            timeStampLastKey = idTimeStamp + "-0"; // <number>-0
            sequence = 0; // start counting from 0
        }

        while (entries.containsKey(timeStampLastKey)) {
            sequence++;
            timeStampLastKey = idTimeStamp + '-' + sequence;
        }

        return timeStampLastKey;
    }

    private long[] parseEntryId(String entryId) {
        String[] parts = entryId.split("-");
        try {
            return new long[]{Long.parseLong(parts[0]), Long.parseLong(parts[1])};
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("ERR Invalid stream ID specified: " + entryId);
        }
    }

    private int compareIDs(String id1, String id2) {
        long[] id1Parts = parseEntryId(id1);
        long[] id2Parts = parseEntryId(id2);

        // compare time first if different
        if (id1Parts[0] != id2Parts[0]) {
            return Long.compare(id1Parts[0], id2Parts[0]);
        }

        // if they are equal, compare sequence numbers
        return Long.compare(id1Parts[1], id2Parts[1]);
    }

    public void validateEntryId(String id) {
        // id must be bigger than 0-0
        if (compareIDs(id, "0-1") < 0) {
            throw new IllegalArgumentException("ERR The ID specified in XADD must be greater than 0-0");
        }

        String lastId = getLastEntryId();
        if (compareIDs(id, lastId) <= 0) {
            throw new IllegalArgumentException("ERR The ID specified in XADD is equal or smaller than the target stream top item");
        }
    }
}
